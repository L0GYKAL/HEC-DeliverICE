archetype delivery

variable currentID : nat  = 0

enum ActorTypes = 
| EXPEDITOR
| COURIER
| RELAY
| RECEIVER

asset actorsType to big_map{
    adr : address;
    aType : ActorTypes;
}

asset parcels identified by id to big_map{
    id : nat;
    currentOwner : address;
    expeditor : address;
    courier : option<address>;
    relay : address;
    receiver : address;
    maxTime : date;
    objectPrice : tez;
    ridePrice : tez;
    hasBeenRelayed : bool;
}

entry createCommand (exp_ : address, relay_ : address, deliveryLimit_ : date, commandValue_ : tez, commandFee_ : tez) {
    const exp_Type ?= actorsType[exp_];
    do_require(exp_Type.aType = EXPEDITOR, "Not expeditor");
    const relay_Type ?= actorsType[relay_];
    do_require(relay_Type.aType = RELAY, "Not relay");
    const callerType ?= actorsType[caller];
    do_require(callerType.aType = RECEIVER, "Not receiver");
    currentID += 1;
    parcels.add({
        id = currentID;
        currentOwner = exp_;
        expeditor = exp_;
        courier = none<address>;
        relay = relay_;
        receiver = caller;
        maxTime = deliveryLimit_;
        objectPrice = commandValue_;
        ridePrice = commandFee_;
        hasBeenRelayed = false})
}

entry reserveCommand(id_ : nat){
    if actorsType[caller].aType = COURIER then begin
        match parcels[id_].courier with
        | some(u) -> fail("Already reserved")
        | none    -> parcels[id_].courier := some(caller)
        end
    end
    else
        fail("You're not a courier")

}

entry takeCommand(id_ : nat){
    if parcels[id_].courier = some(caller) then begin
        if transferred > 1.1*parcels[id_].objectPrice then 
            parcels[id_].currentOwner := caller
        else
            fail("Exception")
    end
    else
        fail("You're not the courier for this delivery")
}

entry slashCollateralForTimelimit(id_ : nat){
    const addOwner = parcels[id_].currentOwner;
    if actorsType[addOwner].aType = COURIER then begin 
        const timeLimit = parcels[id_].maxTime;
        do_require(now > timeLimit, "Timelimit isn't reached");
        const value = parcels[id_].objectPrice;
        const collateral = 1.1*value;
        const addReceiver = parcels[id_].receiver;
        transfer collateral to addReceiver;
        const fees = parcels[id_].ridePrice;
        transfer fees to addReceiver;
    end
    else begin
        fail("not a courier")
    end
}

entry slashCollateralForBadBehavior(id_ : nat){
    const expeditor_ = parcels[id_].expeditor;
    const timeLimit = parcels[id_].maxTime;
    do_require(now > timeLimit, "Timelimit isn't reached");
    do_require(caller = expeditor_, "INVALID CALLER");
    const value = parcels[id_].objectPrice;
    const collateral = 1.1*value;
    const addReceiver = parcels[id_].receiver;
    transfer collateral to addReceiver;
    const fees = parcels[id_].ridePrice;
    transfer fees to addReceiver;
}


/*une adresse ne peut etre qu'un seul acteur a la fois ?
*/

view getOwnerType(id_ : nat) : ActorTypes {
    const owner ?= actorsType[parcels[id_].currentOwner];
    return owner.aType
}
